import networkx as nx
import numpy as np
import math
import pandas as pd
import random
def opinion_climate(a1,Q,network,mis_information):
    '''
    Function to calculate public climate.
    '''
    try:
        n_neighbor=network.degree[a1]
        neighbors=network[a1]
        n1=sum([Q[i,1]>Q[i,0] for i in neighbors])
        n0=sum([Q[i,1]<Q[i,0] for i in neighbors])
        if mis_information==1:
            opinion_climate=(n1-n0)/(n1+n0)
        else :
            opinion_climate=(n0-n1)/(n1+n0)
        opinion_climate=2*(((1+math.exp(-5*opinion_climate))**(-1))-(1/2))
    except:
        opinion_climate=0
    return opinion_climate
def connect_new_friend(Q,a1,indirect_friend,mis_information,h):
    '''
    Fucntion to calculate which nodes to connect.
    '''
    delta_Q1=Q[a1,mis_information]-Q[a1,abs(mis_information-1)]
    sims=[1-abs((delta_Q1-Q[n,mis_information]+Q[n,abs(mis_information-1)]))/4 for n in indirect_friend]
    sims_all=sum([sim**h for sim in sims])
    connect_p=[(sim**2) /sims_all for sim in sims]
    try:
      connect_node=random.choices(list(indirect_friend),connect_p)
    except:
      print(connect_p)
      connect_node=random.choices(list(indirect_friend),1)
    return connect_node[0]
def break_prop(delta_Qi,delta_Qj,b,w):
    '''
    Calculate the probability of disconnecting the spreader
    '''
    conviction=abs(delta_Qj-delta_Qi)
    return (math.exp(conviction*b)/(math.exp(0*b)+math.exp(4*b)))*w
def accept_prop(x,b):
    '''
    Calculate the probability of accepting disinformation
    '''
    a1=1
    a2=-1
    return math.exp(x*b)/(math.exp(a2*b)+math.exp(a1*b))


def dis_information(network,Q,alpha,w,b1,b2, mali_act_a=[], mali_act_0=[],c=0.2):
    '''
    Modeling Process
    Parameters:
        netowrk: network environments, generated by networkx
        Q: the metric of conviction, have Nx2 dimensions where N is the number of nodes.
        alpha: agentâ€™s sensitivity to social pressure.
        w:Network adaptability controls the probability of connect
ing and disconnecting.
        b1: Controls the degree of hardness or softness in the softmax-like function of accepting disinformation
        b2: Controls the degree of hardness or softness in the softmax-like function of disconnection.
        mali_act_1= nodes of  malicious agents with position '1'
        mali_act_0= nodes of  malcious agents position '0'
        c= Probability of connecting friends to friends; otherwise, connecting to random agents in the graph.
    '''
    
    mis_information=np.random.randint(2)
    share_list=[]
    shared_list=[]
    if (mis_information==1 and len(mali_act_1)!=0):
      a1 = np.random.choice( mali_act_1,1)[0]
    elif (mis_information==0 and len(mali_act_0)!=0):
      a1 = np.random.choice( mali_act_0,1)[0]
    else:
      position=Q[:,mis_information]>Q[:,abs(mis_information-1)]
      a1 = np.random.choice(np.array(network.nodes)[position],1)[0]
    shared_list.append(a1)# random choice of agent that expresses his opinion
    while True:
        # update of Q-values for a1 considering what has been expressed
        if a1 in  mali_act_1 or a1 in  mali_act_1:
          Q[a1, mis_information] = Q[a1, mis_information]
        else:
          reward = opinion_climate(a1,Q,network,mis_information)
          Q[a1, mis_information] = (1-alpha)*Q[a1, mis_information]+alpha*reward
        Q_tan=np.tanh(Q)
        
        n_neighbor=network.degree[a1]
        
        neighbors=np.array(network[a1])
        for i in zip(neighbors,[Q_tan[n,mis_information] for n in neighbors]):
            accpet_p=accept_prop(i[1],b=b1)
            if np.random.rand()< accpet_p and i[0] not in shared_list:
                share_list.append(i[0])
                
        shared_list.extend(share_list)
        # break and connect
        not_in_shared_list = np.isin(neighbors, shared_list)
        not_accept=neighbors[not_in_shared_list==False]

        delta_Qi=Q_tan[a1,mis_information]-Q_tan[a1,-(mis_information-1)]
        for i in zip(not_accept,[Q_tan[n,mis_information]-Q_tan[n,abs(mis_information-1)] for n in not_accept]):
            if np.random.rand()<break_prop(delta_Qi,i[1],b=b2,w=w):
                network.remove_edge(a1,i[0])
                
                #if disconnect one, connetct one
                indirect_friend=[]

                if np.random.rand()<=c:
                  indirect_friend=[list(network[n]) for n in neighbors]
                  indirect_friend=list(set([node for sublist in indirect_friend for node in sublist]))
                if len(indirect_friend)==0:
                  indirect_friend=[friend for friend in network.nodes if friend not in neighbors]
                try:
                  new_friend=connect_new_friend(Q_tan,a1,indirect_friend,mis_information,h=2)
                except:
                  print('error')
                  indirect_friend=[friend for friend in network.nodes if friend not in neighbors]
                  new_friend=np.random.choice(indirect_friend,1)[0]
                network.add_edge(a1,new_friend)
                
        
        if len(share_list)==0:

            break
        a1=random.choice(share_list)
        share_list.remove(a1)
    return Q,network,len(set(shared_list)),mis_information